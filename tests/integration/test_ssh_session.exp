#!/usr/bin/expect

# Integration Test: Mock SSH Session
# Tests SSH connection flow with simulated device responses

source [file join [file dirname [info script]] "../lib/test_framework.exp"]

test_suite_start "Mock SSH Session Flow"

# Setup: Create a simple mock SSH script
proc setup {} {
    global mock_ssh_script
    set mock_ssh_script [create_temp_file {#!/bin/bash
# Mock SSH server for testing
while true; do
    read -r line
    case "$line" in
        *"show version"*)
            echo "Cisco IOS XR Software, Version 7.3.1"
            echo "Copyright (c) 2013-2021 by Cisco Systems, Inc."
            echo "RP/0/RP0/CPU0:PHX10-0100-0100-01RHE#"
            ;;
        *"admin"*)
            echo "Entering admin mode..."
            echo "sysadmin-vm:0_RP0#"
            ;;
        *"exit"*)
            echo "Goodbye"
            break
            ;;
        *)
            echo "RP/0/RP0/CPU0:PHX10-0100-0100-01RHE#"
            ;;
    esac
done
}]
    file attributes $mock_ssh_script -permissions 0755
}

proc teardown {} {
    global mock_ssh_script
    cleanup_temp_file $mock_ssh_script
}

# Test Case 1: Basic expect interaction
test_case "handles basic prompt matching" {
    set timeout 5
    
    # Spawn a simple echo process
    spawn bash -c "echo 'RP/0/RP0/CPU0:TEST#'"
    
    expect {
        -re {RP/0/RP0/CPU0:.*#} {
            # Matched the prompt
            set matched 1
        }
        timeout {
            set matched 0
        }
    }
    
    assert_true $matched "Should match device prompt pattern"
}

# Test Case 2: Timeout handling
test_case "handles timeout correctly" {
    set timeout 1
    
    spawn bash -c "sleep 5"
    
    set timed_out 0
    expect {
        "this will never appear" {
            set timed_out 0
        }
        timeout {
            set timed_out 1
        }
    }
    
    assert_true $timed_out "Should timeout when expected"
}

# Test Case 3: Multiple expect patterns
test_case "handles multiple expect patterns" {
    set timeout 5
    
    spawn bash -c "echo 'Password:'"
    
    set matched_pattern ""
    expect {
        "Password:" {
            set matched_pattern "password"
        }
        "password:" {
            set matched_pattern "password_lower"
        }
        timeout {
            set matched_pattern "timeout"
        }
    }
    
    assert_equal $matched_pattern "password" "Should match correct pattern"
}

# Test Case 4: Sending commands
test_case "sends commands and receives output" {
    set timeout 5
    
    spawn bash -c "read cmd; echo \"You entered: \$cmd\""
    
    send "test command\r"
    
    expect {
        "You entered: test command" {
            set received 1
        }
        timeout {
            set received 0
        }
    }
    
    assert_true $received "Should receive echoed command"
}

# Test Case 5: Global variables in admin mode
test_case "tracks admin mode state" {
    global in_admin_mode
    set in_admin_mode 0
    
    # Simulate entering admin mode
    set in_admin_mode 1
    
    assert_equal $in_admin_mode 1 "Should be in admin mode"
    
    # Simulate exiting admin mode
    set in_admin_mode 0
    
    assert_equal $in_admin_mode 0 "Should exit admin mode"
}

# Test Case 6: List operations for messages-LC files
test_case "manages messages-LC file list" {
    global messages_LC_list
    set messages_LC_list {}
    
    # Add files to list
    lappend messages_LC_list "messages-LC1.log"
    lappend messages_LC_list "messages-LC2.log"
    
    assert_equal [llength $messages_LC_list] 2 "Should have 2 files in list"
    assert_contains [lindex $messages_LC_list 0] "messages-LC1.log" "Should contain first file"
}

# Test Case 7: Regex pattern matching
test_case "matches file transfer patterns" {
    set output "Copying file to /harddisk:/showtech/test_20250101.tar.gz"
    
    set matched [regexp {/harddisk:/showtech/(.*\.tar\.gz)} $output full_match filename]
    
    assert_true $matched "Should match file path pattern"
    assert_equal $filename "test_20250101.tar.gz" "Should extract filename"
}

test_suite_end
